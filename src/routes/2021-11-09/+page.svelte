<!-- auto-generated by QWER -->
<script lang="ts">
  /* eslint-disable @typescript-eslint/ban-ts-comment */
  // @ts-nocheck
  import Post from '$lib/layouts/post.svelte';
  import ImgZoom from '$lib/components/image_zoom.svelte';
  import Video from '$lib/components/video.svelte';
  import CodeCopy from '$lib/components/code_copy.svelte';
  import InfoBox from '$lib/components/info_box.svelte';
</script>

<Post>
  <article slot="post_content">
    <h2 id="qian2-yan2"><a href="#qian2-yan2">前言</a></h2>
    <p>
      前一陣子剛完成了人生第一次的it邦幫忙的鐵人賽，連續寫三十天的文章意外地折騰人。 這次我選擇的主題是「Flutter
      web」，雖然現在回頭看跟「Flutter web」基本沒有太大的關係大部分都是在講「Flutter」及「Dart」
    </p>
    <p>這篇文主要是彙整我在這次鐵人賽的中有關Dart基本介紹的部分，大部分內容就是直接搬運過來然後扣掉一些廢話xD</p>
    <p>系列文連結：Flutter web 的奇妙冒險 :: 2021 iThome 鐵人賽</p>
    <h2 id="dart-shi4-shen2-me"><a href="#dart-shi4-shen2-me">Dart是什麼？</a></h2>
    <p>Dart 是一個靜態強型別的語言，同時支援物件導向程式設計（OOP） 及函數式程式設計（FP）的特性，</p>
    <p>
      而Dart 正是「Flutter」所使用的語言，原本是 google 為取代 JavaScript 而設計的語言，所以在語法上借鑑許多 JS
      的特點，而也剛好補足一些我認為的缺點。
    </p>
    <p>相似的地方：</p>
    <ol>
      <li>first-class function</li>
      <li>非同步機制</li>
      <li>基本語法、運算子大部分類似</li>
    </ol>
    <p>相異的地方：</p>
    <ol>
      <li>JS是prototype-base 而 Dart則是 class-base</li>
      <li>Dart 是強型別且支援型別推斷</li>
      <li>Dart 擁有健全的null safety功能</li>
      <li>執行環境</li>
    </ol>
    <p>
      根據以上幾點我認為
      <strong>「Dart 是具有Type保障且是class-base的JS」</strong>
      ，基本上只要是熟悉JS的開發者轉而學習Dart的學習曲線是相當友善的。在網路上其他文章也有看過「Dart是融合JavaScript與Java優點的語言」，但因為我沒使用過Java所以對這個觀點就不多做評論了。如果有使用過Java的讀者可以在底下留言與大家分享一下你的觀點。
    </p>
    <p>
      特別說明一下差異裡的後三點，型別這個問題，有寫過JS的讀者應該都有遇過「xxx is not defined」這種runtime
      error，但如果有型別系統，在開發期間的編輯器靜態檢查就能很大的一部份避免這些問題了。
    </p>
    <p>
      當然如果跟TypeScrpit相比一樣也能達成上面的需求且對於開發體驗的提升也很大，但使用TS有時會遇到第三方package的generic
      type很難標，甚至最後標成 <code class="inline-code-block">any</code>
       。但因為Dart本身就有型別系統所以基本上第三方的pub還是有型別保障的。
    </p>
    <p>
      那 null safety指的是什麼？最大的好處就是我們可以在開發時很有把握的知道這個變數是不是
      <code class="inline-code-block">null</code>
      的而不必其他額外的null判斷，至於是怎麼做到的後面的篇章會介紹到。
    </p>
    <p>（題外話：因為null safety所以現在Dart/Flutter在使用第三方的pub時也是有很多的坑）</p>
    <p>至於執行環境，JS在node出現之前大部分就是直接跑在瀏覽器上</p>
    <p>而Dart本身可以分成兩個平台</p>
    <ol>
      <li>Dart Native</li>
      <li>Dart web</li>
    </ol>
    <p>
      Dart Native：簡單來說就是同時利用Dart
      兩種編譯模式JIT（即時編譯）及AOT（預先編譯），開發時是使用JIT編譯模式跑在Dart
      VM上（可以想像成跟node.js一樣）然後到production時則是採用AOT的形式。 這樣就能讓我們是開發時享受到hot
      reload的之類的好處，而到了production環境時AOT編譯器就會產生出該環境要用machine code，讓程式的啟動時間減少。
    </p>
    <p>
      Dart web：基本上就是將Dart轉成JS，開發環境會使用dartdevc，production則是用dart2js。而flutter
      web也是利用已經成熟的dart2js才得以實現的。
    </p>
    <h2 id="bian4-shu4-xuan1-gao4"><a href="#bian4-shu4-xuan1-gao4">變數宣告</a></h2>
    <p>dart主要有四種方式宣告變數</p>
    <p>
      分別為 <code class="inline-code-block">const</code>
      、
      <code class="inline-code-block">var</code>
      、
      <code class="inline-code-block">type</code>
      、
      <code class="inline-code-block">final</code>
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">const a = 10;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final b = 10;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">var c = 123;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">string d = '123'</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      首先 <code class="inline-code-block">const</code>
      及
      <code class="inline-code-block">final</code>
      這兩個宣告方式就跟js 的
      <code class="inline-code-block">const</code>
       一樣是用於宣告一個「不可變的常數」。
    </p>
    <p>
      亦即這之後不能將這些變數重新賦值。那為什麼還有分 <code class="inline-code-block">const</code>
      及
      <code class="inline-code-block">final</code>
      <code class="inline-code-block">呢？最主要的差異是const</code>
       更為嚴格，它代表的是「編譯時的常數」，什麼意思？
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">int getNumber(a){</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  const b = a;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  return b;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">}</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">void main() {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  int a = 10;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  getNumber(a);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">}</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      這邊會看到我在 <code class="inline-code-block">getNumber</code>
      裡使用
      <code class="inline-code-block">const</code>
      宣告b 將a的值給b ，但這無法通過 Dart的編譯器。因為
      <code class="inline-code-block">const</code>
       的是要在編譯期間就已經是有數值的常數。所以const a = b ; 這種直到runtime才完成初始化的事情是不被允許的。
    </p>
    <p>
      所以const 較常用地方是一些「永遠不變的數值」像是
      <code class="inline-code-block">const pi = 3.14;</code>
      或者
      <code class="inline-code-block">const textColor = Color.fromARGB&lpar;255, 66, 165, 245&rpar;;</code>
    </p>
    <p>
      而 <code class="inline-code-block">final</code>
      就會比較接近於 js裡
      <code class="inline-code-block">const</code>
       的用法，就是在接下來的runtime這個數值都會是不可變更的。
    </p>
    <p>
      var 就可以想成是js的 <code class="inline-code-block">let</code>
      就是可以被變更的變數。但最大的差異就是Dart在宣告完後就會進行型別推斷（Type inference）意即如果
      <code class="inline-code-block">var b = 10</code>
      後不能在進行
      <code class="inline-code-block">b=&#39;123&#39;</code>
      了（可以想像成ts一樣），因為在初始化後將會進行型別推斷（Type inference）將 b 的type定為
      <code class="inline-code-block">int</code>
      <code class="inline-code-block">了所以不能將string</code>
       給b了
    </p>
    <p>
      而直接用型別宣告的方式就跟 <code class="inline-code-block">var</code>
       差不多一樣了就不詳細介紹了，就差別是一個是交由dart 推斷型別一個是我們自己宣告型別。
    </p>
    <p>但其實在變數宣告以及初始化還有一些細節，這部分就留到之後提到「null safety」時再來說明。</p>
    <h2 id="chang2-yong4-xing2-bie2"><a href="#chang2-yong4-xing2-bie2">常用型別</a></h2>
    <p>Dart 有以下基本型別</p>
    <p>1.int, double 2.String 3.bool 4.List 5.Set 6.Map 7.Runes 8.Symbol 9.Null</p>
    <p>基本的 int （整數）、 double （浮點數）、 String （字串）、bool （布林）就不多做介紹。</p>
    <p>以下只稍微介紹一下比較常用到的 List 、 Set、 Map</p>
    <h3 id="list"><a href="#list">List</a></h3>
    <p>而 List 就是其他語言中的陣列（Array）在Dart中的最基礎形式如下：</p>
    <p>
      <code class="inline-code-block">final listA = [1,2,3,4];</code>
      在Dart裡的List有提供其他建構子（constructor）
      <code class="inline-code-block">.filled</code>
      及
      <code class="inline-code-block">.generate</code>
       都是可以用來動態產生list的建構子：
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final listB = List.filled(3, 1); // [0, 0, 0]</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final listC = List.generate(3, (index) =&gt; index); // [0, 1, 2]</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>差異是 filled 每一個element都是同一個reference而 generate 不是。</p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">listB[0].add(1);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">listC[0].add(1);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">print(listB); // [[1], [1], [1]]</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">print(listC); // [[1], [], []]</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      以及其中有一個控制這個List是不是可變長度的named parameters growable
      的預設值不一樣。但詳細就不贅述了有興趣的讀者可以到官方的API文件閱讀。
    </p>
    <h3 id="set"><a href="#set">Set</a></h3>
    <p>定義為「沒有索引值且不可重複的集合」</p>
    <p>
      我們可以用 <code class="inline-code-block">&lcub;&rcub;</code>
       來做初始化並用逗號分隔每一個元素：
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final setA = {0, 1, 2, 3, 4};</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">print(setA); // {0, 1, 2, 3, 4}</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      也可以利用 <code class="inline-code-block">Set.from</code>
       放入一個可迭代的值來產生 Set
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final listX = [0, 1, 0, 0, 1, 2, 1, 3, 4, 5, 6, 7];</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final setB = Set.from(listX);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">print(setB); //{0, 1, 2, 3, 4, 5, 6, 7}</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      因為 Set 裡並沒有存放索引值，所以我們無法直接存取特定位置的值。但因為 Dart 底層實作的關係，其實還是有將 Set
      的順序存入，也因此我們迭代時是會跟初始化時的順序一樣：
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">setB.forEach((element) {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">    print(element);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">});</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">// 0</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">// 1</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">// ...</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">// 7</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <h3 id="map"><a href="#map">Map</a></h3>
    <p>Map就是有key-value型式的資料結構，而且key不能重複，也因為了有了key所以我們有辦法直接存取Map。</p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final mapA = {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  'a': 1,</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  'b':2,</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  'c':3</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">};</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">mapA['a'] // 1</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>當然Map也有提供其他的constructor：</p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final mapB = Map.fromIterable([1, 2, 3, 4]);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">// {1: 1, 2: 2, 3: 3, 4: 4}</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final valueList = [0, 1, 2];</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final keyList = ['z', 'x', 'c'];</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final mapC = Map.fromIterables(keyList, valueList);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">// {z: 0, x: 1, c: 2}</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      當然這些資料結構還有其他API可以介紹，但我覺得還是等到之後實際有用到時在一起介紹好了，有興趣的讀者可以先查閱Dart
      API的文件。
    </p>
    <p>泛型 泛型（generic）最簡單的解釋大概就是型別有了參數。</p>
    <p>
      通常都是使用 <code class="inline-code-block">&lt;&gt;</code>
      來實作，像是List的實作是
      <code class="inline-code-block">List&lt;E&gt;</code>
       而這個E就是我們可以傳入的型別：
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final intList = &lt;int&gt;[1, 2, 3, 4];</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final stringList = &lt;String&gt;['1', '2', '3', '4'];</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      而當我們使用了不一樣的型別時就會跳出 Error，像是我在 <code class="inline-code-block">List&lt;String&gt;</code>
       裡放入一個 int 就會跳出以下錯誤：
    </p>
    <p>當然我們也可以運用到其他地方像是 Class 或者 Function上</p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">E ientityFunc&lt;E&gt;(E e) =&gt; e;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">class A&lt;T&gt; {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  T? value;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">}</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">print(ientityFunc&lt;int&gt;(2)); // 2</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final a = A&lt;int&gt;();</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">a.value = 'string';  // 這行會出錯因為 A傳入的是 int type</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      而關於型別有一些進階應用像是利用 <code class="inline-code-block">typedef</code>
       對Function的型別做更進一步的抽象
    </p>
    <p>
      <code class="inline-code-block">typedef Identity&lt;E&gt; = E Function&lpar;E e&rpar;;</code>
      這行的意思就是我定義了一個型別叫做Identity，而這個型別代表的意義就是他是一個會回傳 type E 的 Function 且只有一個type
      E 的參數。
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">class Utils&lt;T&gt; {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  Identity&lt;T&gt; ientity = (x) =&gt; x;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">}</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">final utils = Utils&lt;int&gt;();</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">print(utils.ientity(1));</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      我們可以從vs code中看到因為我們傳入了 int 所以 <code class="inline-code-block">utils.ientity</code>
       也變成有一個 int 參數且會回傳 int 的 Function
    </p>
    <h3 id="class"><a href="#class">Class</a></h3>
    <p>
      前面說到 Dart 是一個支援OOP的程式語言，不同於JS的Prototype-based，Dart 則是
      Class-based，所以在OOP上會比較像是Java之類的語言。
    </p>
    <p>在 Dart 中 class的宣告很簡單</p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">class Person {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  final String name;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  final int age;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  final String email;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  late final String position; // 請先無視這個late 之後會提到null safety時會再說明</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  Person(this.position,</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">      {required this.name, required this.age, required this.email});</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  Person.developer(</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">      {required this.name, required this.age, required this.email}) {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">    this.position = 'developer';</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  }</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  void hello() {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">    print('hi 我是 &#36;name 我的職業是 &#36;position');</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  }</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">}</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      我們可以直接宣告一些變數來表示這個class的fields以及一些function來表示這個class的method，這些統稱是class
      members，那這個與class同名的function Person 是什麼呢？
    </p>
    <p>
      這個就是所謂的建構子（constructor），在OOP中 class
      可以想像成一個模板，而所謂的物件就是按照模板產生出來的東西，這個過程又稱為實體化（instantiation）
    </p>
    <p>
      而在OOP裡負責這件事情就是 constructor
      ，而constructor當然可以不只有一個，我們可以宣告多個constructor來因應各種需求，像是可能許多人的 position 都是
      developer那我們可以宣告一個 constructor 叫做 Person.developer 來減少我們只用原本的constructor還要一直多傳 position
      的煩躁感。
    </p>
    <p>真正在程式中run起來會像是這樣子：</p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">void main() {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  final todd = Person('developer',name:'todd',age:25,email:'123@gamil.com');</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  final larry = Person.developer(age:25,name:'larry',email:'456@gamil.com');</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  print(todd.email);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  print(todd.name);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  print(todd.job);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  print(todd.age);</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  todd.hello();</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  larry.hello();</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">}</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      也許有人已經注意到為什麼在 <code class="inline-code-block">
        Person&lpar;this.position, &lcub;required this.name, required this.age, required this.email&rcub;&rpar;;
      </code>
    </p>
    <p>
      有些參數是放在 <code class="inline-code-block">&lcub;&rcub;</code>
      裡有些參數是放在前面，他們差別在哪裡？
      <br />
      直接放在前面的參數是required positional parameters 而放到大括號中的是 Named parameters。
    </p>
    <p>
      從這個例子先不考慮有default value（optional parameters ）的情況下我們就能看得出 positional
      parameters它就跟一般function一樣我們要依照參數的順序放入我們的數值，而Named
      parameters就是我們以key:value的形式傳入參數而且順序可以隨意。
    </p>
    <h2 id="factory"><a href="#factory">Factory</a></h2>
    <p>
      在 Dart class constructor 中有提供一個語法糖 factory ，我們先來看看它的大概會長怎麼樣，稍微將上面的 Person Class
      修改一下後：
    </p>
    <div class="code-block">
      <CodeCopy>
        <pre><code
            class="language-dart">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">class Person {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  final String name;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  final int age;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  final String email;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  late final String position;</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  Person(</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">      {required this.name,</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">      required this.age,</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">      required this.email,</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">      required this.position});</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  Person.developer(</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">      {required this.name, required this.age, required this.email}) {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">    this.position = 'developer';</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  }</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  factory Person.todd(String name) {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">    return Person(</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">        name: name, age: 25, email: '123@gamil.com', position: 'developer');</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  }</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  void hello() {</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">    print('hi 我是 &#36;name 我的職業是 &#36;position');</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  }</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">}</div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>
      最直觀的差異就是 factory constructor 會回傳一個 instance ，而不是像一般的 constructor
      只要傳入值或者對this操作來設定值且不用另外撰寫return相關的語法。也因為是直接回傳instance所以就無法對this操作。
    </p>
    <p>那實際上 factory 有什麼用途？</p>
    <p>大致上有三種</p>
    <p>
      我希望不是每一次呼叫constructor都一定會建立一個新的instance，而是根據情況來決定要不要創建新的instance
      我希望這個class 只能有一個instance（沒錯就是單例模式，singleton pattern ）
      不是要回傳這個class而是要回傳這個它的子class 詳細用法請參考：
      <a
        href="https://stackoverflow.com/questions/53886304/understanding-factory-constructor-code-example-dart"
        rel="external">
        https://stackoverflow.com/questions/53886304/understanding-factory-constructor-code-example-dart
      </a>
    </p>
  </article>
</Post>
